import torch
from sklearn.model_selection import train_test_split
import muller_learned
import numpy as np
import matplotlib.pyplot as plt
import verlet_muller

# Load the model architecture
loaded_model = muller_learned.GradientModel()

# Load the saved parameters
loaded_model.load_state_dict(torch.load('trained_model.pth'))
loaded_model.eval()  # Set the model to evaluation mode

# Generate x and y values
x = np.linspace(-5, 5, 100)
y = np.linspace(-5, 5, 100)

# Create a meshgrid from x and y
xx, yy = np.meshgrid(x, y)

# Convert meshgrid to tensors
xx_tensor = torch.tensor(xx, dtype=torch.float32)
yy_tensor = torch.tensor(yy, dtype=torch.float32)

# Concatenate the tensors along a new dimension
input_tensor = torch.stack([xx_tensor, yy_tensor], dim=-1)

# Reshape the input tensor to (num_samples, num_features)
input_tensor = input_tensor.view(-1, 2)

# Pass the input tensor through the model
with torch.no_grad():
    potential_grid = loaded_model(input_tensor).view(xx.shape[0], xx.shape[1], -1)



n = 3 #Nombre de particules
dt = 0.01 #Pas de temps
num_steps = 100  #Nombre d'it√©rations 
m = 1 #Masse des particules


q_learned=np.random.rand(n,num_steps,2)
p_learned=np.random.rand(n,num_steps,2)

#Copy q_learned and p_learned to q and p


for q_0,p_0 in zip(q_learned,p_learned):
    for i in range(1, num_steps):

        #transform the q_0[i-1] to tensor
        q_i = torch.tensor(q_0[i-1], dtype=torch.float32)
        grad_v= loaded_model(torch.tensor(q_i, dtype=torch.float32)).detach().numpy()

        q_0[i], p_0[i] = verlet_muller.verlet_scheme_first_half_iteration(grad_v, q_0[i-1], p_0[i-1], dt, m)

        #transform the q_0[i] to tensor
        q_0_i = torch.tensor(q_0[i], dtype=torch.float32)

        grad_v= loaded_model(torch.tensor(q_0_i, dtype=torch.float32)).detach().numpy()
        
        q_0[i], p_0[i] = verlet_muller.verlet_scheme_second_half_iteration(grad_v, q_0[i], p_0[i], dt, m)

m=np.ones(n)

trajectories, _ = verlet_muller.verlet_scheme_n_particule(q_learned[:,0,:], p_learned[:,0,:], dt, m, num_steps)

#plot the trajectories
fig, ax = plt.subplots()
particle_colors = {
    0: 'red',
    1: 'blue',
    2: 'green',
    3: 'purple',
    4: 'orange',
    # Add more entries as needed
}

for i in range(n):
    ax.plot(trajectories[i,:,0], trajectories[i,:,1], '+', markersize=2,color=particle_colors[i])

for i in range(n):
    ax.plot(q_learned[i,:,0], q_learned[i,:,1], 'o', markersize=2,color=particle_colors[i])


plt.show()
